package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal ELSE, PLUS, RBRACE, RPAREN, ASSIGN, SEMI, RETURN, IF, LPAREN, LBRACE,
COMMA, PROG, PRINT, VOID, BREAK, CONST, NEW, READ, FOR, CONTINUE, INC, DEC,
MINUS, MUL, DIV, MOD, AND, OR, EQ, NOTEQ, GR, GEQ, LS, LEQ, LBRACKET, RBRACKET,
DOT, BOOLCONST, CHARCONST, CLASS, ABSTRACT, EXTENDS;
terminal Integer NUMBERCONST;
terminal String IDENT;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, AddopExpr, VarDeclList, RetType,
Factor; 


nonterminal MethodDeclList MethodDeclList;
nonterminal VarDeclar VarDeclar;
nonterminal DeclVar DeclVar;
nonterminal ConstInitializer ConstInitializer;
nonterminal Initializer Initializer;
nonterminal VarIdentList VarIdentList;
nonterminal VarIdent VarIdent;
nonterminal FormalParamList FormalParamList;
nonterminal
FormalParamDecl FormalParamDecl;
nonterminal FormPars FormPars;
nonterminal Statements Statements;
nonterminal Statement Statement;
nonterminal AbstractModif AbstractModif;
nonterminal ClassExtends ClassExtends;
nonterminal ClassVarDeclList ClassVarDeclList;
nonterminal ClassMethDeclList ClassMethDeclList;
nonterminal
DeclVarList DeclVarList;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ForCond ForCond;
nonterminal AssignStmnt AssignStmnt;
nonterminal ActualParamsList ActualParamsList;
nonterminal
ActualParams ActualParams;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal PrintExpression PrintExpression;
nonterminal ForDesignatorStm ForDesignatorStm;
nonterminal DesignatorList DesignatorList;
nonterminal ElsePart ElsePart;


precedence left ELSE;


Program ::= (Program) PROG ProgName:p VarDeclList:V1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, V1, M2); RESULT.setLine(pleft); :} 
;

ProgName ::= (ProgName) IDENT:pName {: RESULT=new ProgName(pName); RESULT.setLine(pNameleft); :}
;

VarDeclList ::= (VarDeclarations) VarDeclList:V1 VarDeclar:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}  
				|
				(NoVarDeclarations) {: RESULT=new NoVarDeclarations(); :}/* epsilon */ 
;
			
VarDeclar ::= (VarDeclConst) CONST Type:T1 ConstInitializer:C2 SEMI {: RESULT=new VarDeclConst(T1, C2); RESULT.setLine(T1left); :}
			  | 
			  (VarDeclNonConst) DeclVar:D1 {: RESULT=new VarDeclNonConst(D1); RESULT.setLine(D1left); :}
			  |
			  (VarDeclClass) AbstractModif:A1 CLASS IDENT:I2 ClassExtends:C3 LBRACE ClassVarDeclList:C4 ClassMethDeclList:C5 RBRACE {: RESULT=new VarDeclClass(A1, I2, C3, C4, C5); RESULT.setLine(A1left); :}
;

DeclVar ::= (VariableDeclaration) Type:T1 VarIdentList:V2 SEMI {: RESULT=new VariableDeclaration(T1, V2); RESULT.setLine(T1left); :}
            |
            (VariableDeclarationError) error SEMI
            {: parser.report_info("GRESKA: deklaracija promenljive; Uspesno izvrsen oporavak od greske!", null);  :} {: RESULT=new VariableDeclarationError(); :}
;

VarIdentList ::= (MultipleVariableIdentList) VarIdentList:V1 COMMA VarIdent:V2 {: RESULT=new MultipleVariableIdentList(V1, V2); RESULT.setLine(V1left); :}
                 |
                 (SingleVariableIdentList) VarIdent:V1 {: RESULT=new SingleVariableIdentList(V1); RESULT.setLine(V1left); :}
;

VarIdent ::= (SingleVariableIdent) IDENT:name {: RESULT=new SingleVariableIdent(name); RESULT.setLine(nameleft); :}
              |
              (ArrayVariableIdent) IDENT:name LBRACKET RBRACKET {: RESULT=new ArrayVariableIdent(name); RESULT.setLine(nameleft); :}
              |
              (VariableIdentError) error
              {: parser.report_info("GRESKA: identifikator promenljive; Uspesno izvrsen oporavak od greske!", null);  :} {: RESULT=new VariableIdentError(); :}
;

        
DeclVarList ::= (VariableDeclarationList) DeclVarList:D1 DeclVar:D2 {: RESULT=new VariableDeclarationList(D1, D2); RESULT.setLine(D1left); :}
                |
                (NoVariableDeclarationList) {: RESULT=new NoVariableDeclarationList(); :} /* epsilon */
;

AbstractModif ::= (AbstractModifer) ABSTRACT {: RESULT=new AbstractModifer(); :}
				  |
				  (NoAbstractModifer) {: RESULT=new NoAbstractModifer(); :} /* epsilon */
;

ClassExtends ::= (Extension) EXTENDS Type:T1 {: RESULT=new Extension(T1); RESULT.setLine(T1left); :}
				|
				(NoExtesion) {: RESULT=new NoExtesion(); :} /* epsilon */
;
				
ClassVarDeclList ::= (ClassVarDeclarationList) ClassVarDeclList:C1 VarDeclar:V2 {: RESULT=new ClassVarDeclarationList(C1, V2); RESULT.setLine(C1left); :}
					|
					(NoClassVarDeclarationList) {: RESULT=new NoClassVarDeclarationList(); :} /* epsilon */
;	

ClassMethDeclList ::= (ClassMethodDeclList) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new ClassMethodDeclList(M1); RESULT.setLine(M1left); :}
					|
					(NoClassMethodDeclList) {: RESULT=new NoClassMethodDeclList(); :} /* epsilon */
;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :} 
;

ConstInitializer ::= (ConstInitializerList) ConstInitializer:C1 COMMA Initializer:I2 {: RESULT=new ConstInitializerList(C1, I2); RESULT.setLine(C1left); :}
             		 |
             		 (SingleConstInitializer) Initializer:I1 {: RESULT=new SingleConstInitializer(I1); RESULT.setLine(I1left); :}
;
             
Initializer ::= (NumConstInitializer) IDENT:name ASSIGN NUMBERCONST:val {: RESULT=new NumConstInitializer(name, val); RESULT.setLine(nameleft); :}
				|
          		(CharConstInitializer) IDENT:name ASSIGN CHARCONST:val {: RESULT=new CharConstInitializer(name); RESULT.setLine(nameleft); :}
          		|
          		(BoolConstInitializer) IDENT:name ASSIGN BOOLCONST:val {: RESULT=new BoolConstInitializer(name); RESULT.setLine(nameleft); :}
;


MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :}/* epsilon */
;

MethodDecl ::= (MethodDeclaration) MethodTypeName:M1 LPAREN FormPars:F2 RPAREN DeclVarList:D3 LBRACE Statements:S4 RBRACE {: RESULT=new MethodDeclaration(M1, F2, D3, S4); RESULT.setLine(M1left); :}
			   |
			   (AbstractMethodDeclaration) ABSTRACT MethodTypeName:M1 LPAREN FormPars:F2 RPAREN SEMI {: RESULT=new AbstractMethodDeclaration(M1, F2); RESULT.setLine(M1left); :}
;

MethodTypeName ::= (MethodTypeName) RetType:retType IDENT:methName {: RESULT=new MethodTypeName(retType, methName); RESULT.setLine(retTypeleft); :}
;

RetType ::= (VoidReturnType) VOID {: RESULT=new VoidReturnType(); :}
             |
            (ReturnType) Type:T1 {: RESULT=new ReturnType(T1); RESULT.setLine(T1left); :}
;
                            
FormPars ::= (FormParams) FormalParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :} 
			 | 
			(NoFormParam) {: RESULT=new NoFormParam(); :} /* epsilon */ 
;

FormalParamList ::= (FormalParamDecls) FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamDecls(F1, F2); RESULT.setLine(F1left); :}
					|
					(SingleFormalParamDecl) FormalParamDecl:F1 {: RESULT=new SingleFormalParamDecl(F1); RESULT.setLine(F1left); :}
;
					
FormalParamDecl ::= (SimpleFormalParameter) Type:T1 IDENT:name {: RESULT=new SimpleFormalParameter(T1, name); RESULT.setLine(T1left); :}
                     |
                     (ArrayFormalParameter) Type:T1 IDENT:name LBRACKET RBRACKET {: RESULT=new ArrayFormalParameter(T1, name); RESULT.setLine(T1left); :}
                     |
                     (FormalParameterError) error
                     {: parser.report_info("formal parameter error recovery: successful", null); :} {: RESULT=new FormalParameterError(); :}
;

Statements ::= (StatementsList) Statements:S1 Statement:S2 {: RESULT=new StatementsList(S1, S2); RESULT.setLine(S1left); :} 
				|
			   (NoStatementsList) {: RESULT=new NoStatementsList(); :} /* epsilon */
;

Statement ::= (ReturnStatement) RETURN SEMI {: RESULT=new ReturnStatement(); :}
			  |
			  (BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
              |
              (ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
              |
              (ReturnExpressionStatement) RETURN Expr:E1 SEMI {: RESULT=new ReturnExpressionStatement(E1); RESULT.setLine(E1left); :}
              |
              (ReadStatement) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
              |
              (PrintStatement) PRINT LPAREN PrintExpression:P1 RPAREN SEMI {: RESULT=new PrintStatement(P1); RESULT.setLine(P1left); :}
              |
              (IfStatement) IF LPAREN Condition:C1 RPAREN Statement:S2 ElsePart:E3 {: RESULT=new IfStatement(C1, S2, E3); RESULT.setLine(C1left); :}
              |
          	  (ForStatement) FOR LPAREN ForDesignatorStm:F1 SEMI ForCond:F2 SEMI ForDesignatorStm:F3 RPAREN Statement:S4 {: RESULT=new ForStatement(F1, F2, F3, S4); RESULT.setLine(F1left); :}
              |
              (StatementDesignator) DesignatorStatement:D1 SEMI {: RESULT=new StatementDesignator(D1); RESULT.setLine(D1left); :}
              |
              (BlockOfStatements) LBRACE Statements:S1 RBRACE {: RESULT=new BlockOfStatements(S1); RESULT.setLine(S1left); :}
              |
              (ProcCall) Designator:func LPAREN ActualParamsList:A1 RPAREN SEMI {: RESULT=new ProcCall(func, A1); RESULT.setLine(funcleft); :}
              
;       

Expr  ::= (PositiveExpression) AddopExpr:A1 {: RESULT=new PositiveExpression(A1); RESULT.setLine(A1left); :}
          |
          (NegativeExpression) MINUS AddopExpr:A1 {: RESULT=new NegativeExpression(A1); RESULT.setLine(A1left); :};

AddopExpr ::= (MultipleAddopTerm) AddopExpr:A1 Addop:A2 Term:T3 {: RESULT=new MultipleAddopTerm(A1, A2, T3); RESULT.setLine(A1left); :}
               |
              (SingleAddopTerm) Term:T1 {: RESULT=new SingleAddopTerm(T1); RESULT.setLine(T1left); :};

Term ::= (MultipleFactor) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new MultipleFactor(T1, M2, F3); RESULT.setLine(T1left); :}
          |
         (SingleFactor) Factor:F1 {: RESULT=new SingleFactor(F1); RESULT.setLine(F1left); :};

Factor ::= (NumberConstFactor) NUMBERCONST:val {: RESULT=new NumberConstFactor(val); RESULT.setLine(valleft); :}
            |
           (CharConstFactor) CHARCONST:val {: RESULT=new CharConstFactor(); :}
            |
           (BoolConstFactor) BOOLCONST:val {: RESULT=new BoolConstFactor(); :}
            |
		   (DesignatorFactor) Designator:D1 {: RESULT=new DesignatorFactor(D1); RESULT.setLine(D1left); :}
            |
           (NewObjectFactor) NEW Type:T1 {: RESULT=new NewObjectFactor(T1); RESULT.setLine(T1left); :}
            |
           (NewObjectArrayFactor) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new NewObjectArrayFactor(T1, E2); RESULT.setLine(T1left); :}
            |
           (FuncCall) Designator:func LPAREN ActualParamsList:A1 RPAREN {: RESULT=new FuncCall(func, A1); RESULT.setLine(funcleft); :}
            |
           (ParenFactor) LPAREN Expr:E1 RPAREN {: RESULT=new ParenFactor(E1); RESULT.setLine(E1left); :}
;

Designator ::= (Designator) IDENT:designatorName DesignatorList:D1 {: RESULT=new Designator(designatorName, D1); RESULT.setLine(designatorNameleft); :}
;

DesignatorList ::= (DesignatorListDot) DesignatorList:D1 DOT IDENT:designatorId {: RESULT=new DesignatorListDot(D1, designatorId); RESULT.setLine(D1left); :}
					| 
					(DesignatorListExpr) DesignatorList:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorListExpr(D1, E2); RESULT.setLine(D1left); :}
					|
					(NoDesignatorList) {: RESULT=new NoDesignatorList(); :} /* epsilon */
;

DesignatorStatement ::= (IncDesignatorStatement) Designator:D1 INC {: RESULT=new IncDesignatorStatement(D1); RESULT.setLine(D1left); :}
                         |
                        (DecDesignatorStatement) Designator:D1 DEC {: RESULT=new DecDesignatorStatement(D1); RESULT.setLine(D1left); :}
                         |
						(AssignDesignatorStatement) AssignStmnt:A1 {: RESULT=new AssignDesignatorStatement(A1); RESULT.setLine(A1left); :}         
;

AssignStmnt ::= (AssignStatement) Designator:D1 ASSIGN Expr:E2 {: RESULT=new AssignStatement(D1, E2); RESULT.setLine(D1left); :}
                 |
                (AssignStatementError) error
                {: parser.report_info("assign statement error recovery: successful", null); :} {: RESULT=new AssignStatementError(); :}
;

ActualParamsList ::= (ActualParametersList) ActualParams:A1 {: RESULT=new ActualParametersList(A1); RESULT.setLine(A1left); :}
                  	  |
                 	 (NoActualParametersList) {: RESULT=new NoActualParametersList(); :} /* epsilon */
;
                            
ActualParams ::= (MultipleActualParameters) ActualParams:A1 COMMA Expr:E2 {: RESULT=new MultipleActualParameters(A1, E2); RESULT.setLine(A1left); :}
             	 |
            	 (SingleActualParameter) Expr:E1 {: RESULT=new SingleActualParameter(E1); RESULT.setLine(E1left); :}
;

PrintExpression ::= (SinglePrintExpression) Expr:exp {: RESULT=new SinglePrintExpression(exp); RESULT.setLine(expleft); :}
                    |
                    (MultiplePrintExpression) Expr:exp COMMA NUMBERCONST:val {: RESULT=new MultiplePrintExpression(exp, val); RESULT.setLine(expleft); :}
;

ElsePart ::= (ElseStatement) ELSE Statement:S1 {: RESULT=new ElseStatement(S1); RESULT.setLine(S1left); :}
			 | 
			 (NoElseStatement) {: RESULT=new NoElseStatement(); :} /* epsilon */
;

ForDesignatorStm ::= (ForDesignatorStatement) DesignatorStatement:D1 {: RESULT=new ForDesignatorStatement(D1); RESULT.setLine(D1left); :}
                      |
                     (NoForDesignatorStatement) {: RESULT=new NoForDesignatorStatement(); :} /* epsilon */
;
                     
ForCond ::= (ForCondition) Condition:C1 {: RESULT=new ForCondition(C1); RESULT.setLine(C1left); :}
             |
            (NoForCondition) {: RESULT=new NoForCondition(); :} /* epsilon */
;

Condition ::= (MultipleCondition) Condition:C1 OR CondTerm:C2 {: RESULT=new MultipleCondition(C1, C2); RESULT.setLine(C1left); :}
               |
              (SingleCondition) CondTerm:C1 {: RESULT=new SingleCondition(C1); RESULT.setLine(C1left); :}
               |
              (IllegalConditionError) error
             {: parser.report_info("illegal condition error recovery: successful", null); :} {: RESULT=new IllegalConditionError(); :}
;

CondTerm ::= (MultipleFactorConditionTerm) CondTerm:C1 AND CondFact:C2 {: RESULT=new MultipleFactorConditionTerm(C1, C2); RESULT.setLine(C1left); :}
              |
             (SingleFactorConditionTerm) CondFact:C1 {: RESULT=new SingleFactorConditionTerm(C1); RESULT.setLine(C1left); :}
;

CondFact ::= (ExprConditionFactor) Expr:E1 {: RESULT=new ExprConditionFactor(E1); RESULT.setLine(E1left); :}
              |
             (RelopExprConditionFactor) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new RelopExprConditionFactor(E1, R2, E3); RESULT.setLine(E1left); :}
;
             
Addop  ::= (AddopADD) PLUS {: RESULT=new AddopADD(); :}
           |
           (AddopSUB) MINUS {: RESULT=new AddopSUB(); :}
;

Mulop  ::= (MulopMUL) MUL {: RESULT=new MulopMUL(); :}
            |
           (MulopDIV) DIV {: RESULT=new MulopDIV(); :}
            |
           (MulopMOD) MOD {: RESULT=new MulopMOD(); :}
;
             
Relop ::= (RelopEQ) EQ {: RESULT=new RelopEQ(); :}
           |
          (RelopNOTEQ) NOTEQ {: RESULT=new RelopNOTEQ(); :}
           |
          (RelopGR) GR {: RESULT=new RelopGR(); :}
           |
          (RelopGEQ) GEQ {: RESULT=new RelopGEQ(); :}
           |
          (RelopLS) LS {: RESULT=new RelopLS(); :}
           |
          (RelopLEQ) LEQ {: RESULT=new RelopLEQ(); :}
;

