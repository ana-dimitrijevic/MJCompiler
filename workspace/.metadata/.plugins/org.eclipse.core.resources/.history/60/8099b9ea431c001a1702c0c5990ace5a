package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal ELSE; 
terminal PLUS;
terminal RBRACE;
terminal RPAREN;
terminal ASSIGN;
terminal SEMI;
terminal RETURN;
terminal IF;
terminal LPAREN;
terminal LBRACE;
terminal COMMA;
terminal PROG;
terminal PRINT;
terminal VOID;
terminal BREAK;
terminal CONST;
terminal NEW;
terminal READ;
terminal FOR;
terminal CONTINUE;
terminal INC;
terminal DEC;
terminal MINUS;
terminal MUL;
terminal DIV;
terminal MOD;
terminal AND;
terminal OR;
terminal EQ;
terminal NOTEQ;
terminal GR;
terminal GEQ;
terminal LS;
terminal LEQ;
terminal LBRACKET;
terminal RBRACKET;
terminal DOT;
terminal BOOLCONST;
terminal CHARCONST;
terminal CLASS;
terminal ABSTRACT;
terminal EXTENDS;
terminal Integer NUMBERCONST;
terminal String IDENT;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct VarDeclList; 


nonterminal MethodDeclList;
nonterminal VarDeclar;
nonterminal DeclVar;
nonterminal InitList;
nonterminal Init;
nonterminal VarIdentList;
nonterminal VarIdent;
nonterminal FormalParamList;
nonterminal FormalParamDecl;
nonterminal FormPars;
nonterminal ActualPars;
nonterminal ActualParamList; 
nonterminal StatementList;
nonterminal Statement;
nonterminal Addop;
nonterminal Unmatched, Matched;
nonterminal AbstractModif;
nonterminal ClassExtends;
nonterminal ClassVarDeclList;
nonterminal ClassMethDeclList;
nonterminal RetType;


precedence left ELSE;


Program ::= (Program) PROG ProgName:p VarDeclList LBRACE MethodDeclList RBRACE 
;

ProgName ::= (ProgName) IDENT:pName
;

VarDeclList ::= (VarDeclarations) VarDeclList VarDeclar  
				|
				(NoVarDeclarations)/* epsilon */ 
;
		
//(VarDecl) Type:varType IDENT:varName ArrayModif SEMI		
	
VarDeclar ::= (VarDeclConst) CONST Type InitList SEMI
			  | 
			  (VarDeclNonConst) Type VarIdentList SEMI 	
			  |
			  (ClassDecl) AbstractModif CLASS IDENT ClassExtends LBRACE ClassVarDeclList ClassMethDeclList RBRACE
;

VarDeclaratio ::= (VarDecl) Type:varType IDENT:varName SEMI 
;

AbstractModif ::= (AbstractModifer) ABSTRACT
				  |
				  (NoAbstractModifer) /* epsilon */
				;

ClassExtends ::= (Extension) EXTENDS Type
				|
				(NoExtesion) /* epsilon */
				;
				
ClassVarDeclList ::= (ClassVarDeclarationList) ClassVarDeclList VarDeclar
					|
					(NoClassVarDeclarationList) /* epsilon */
					;	

ClassMethDeclList ::= (ClassMethodDeclList) LBRACE MethodDeclList RBRACE
					|
					(NoClassMethodDeclList) /* epsilon */
					;

Type ::= (Type) IDENT:typeName 
;

InitList ::= (InitializerList) InitList COMMA Init
             |
             (SingleInitializer) Init
;
             
Init ::= (NumConstInitializer) IDENT:name ASSIGN NUMBERCONST:val
          |
          (BoolConstInitializer) IDENT:name ASSIGN BOOLCONST:val
          |
          (CharConstInitializer) IDENT:name ASSIGN CHARCONST:val
;
        
DeclVar ::= (VariableDeclaration) Type VarIdentList SEMI
            |
            (VariableDeclarationError) error SEMI
            {: parser.report_info("GRESKA: deklaracija promenljive; Uspesno izvrsen oporavak od greske!", null);  :}
;


VarIdentList ::= (MultipleVariableIdentList) VarIdentList COMMA VarIdent
                 |
                 (OneVariableIdentList) VarIdent
;

VarIdent ::= (SingleVariableIdent) IDENT:name
              |
              (ArrayVariableIdent) IDENT:name LBRACKET RBRACKET
              |
              (VariableIdentError) error
              {: parser.report_info("GRESKA: identifikator promenljive; Uspesno izvrsen oporavak od greske!", null);  :}
;

// APSTRAKTNA KLASA !!!

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDeclaration) MethodTypeName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			   |
			   (AbstractMethodDeclaration) ABSTRACT MethodTypeName LPAREN FormPars RPAREN SEMI
;

MethodTypeName ::= (MethodTypeName) RetType:retType IDENT:methName
;

RetType ::= (VoidReturnType) VOID
             |
            (ReturnType) Type;
                            
FormPars ::= (FormParams) FormalParamList 
			 | 
			(NoFormParam) /* epsilon */ ;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
					|
					(SingleFormalParamDecl) FormalParamDecl
					;
					
FormalParamDecl ::= (SimpleFormalParameter) Type IDENT:name
                     |
                     (ArrayFormalParameter) Type IDENT:name LBRACKET RBRACKET
                     |
                     (FormalParameterError) error
                     {: parser.report_info("formal parameter error recovery: successful", null); :};



StatementList ::= (Statements) StatementList Statement 
					|
				  (NoStmt) /* epsilon */
				  ;

Statement ::= (MatchedStmt) Matched | (UnmachedStmt) Unmatched ;

Unmatched ::= (UnmatchedIf) IF Expr Statement | (UnmatchedIfElse) IF Expr Matched ELSE Unmatched;
	
				  
Matched ::= (Assignment) Designator:dest ASSIGN Expr:e SEMI 
			  |
			  (ErrAssignment) Designator ASSIGN error SEMI
			  {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :}
			  |
			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			  (ReturnExpr) RETURN Expr:t SEMI
			  |
			  (ReturnNoExpr) RETURN SEMI
			  | 
			  (MatchedIf) IF Expr Matched ELSE Matched
			  |
			  (ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
			  ;
			  
Expr ::= (AddExpr) Expr:te Addop Term:t
		 |
		 (TermExpr) Term:t
		 ;

Term ::= (Term) Factor:t 
;

Factor ::= (Const) NUMBERCONST
			|
		   (Var) Designator:d
		    |
		   (FuncCall) Designator:func LPAREN ActualPars RPAREN
		   ;

ActualPars ::= (Actuals) ActualParamList 
				| 
			   (NoActuals) /* epsilon */ 
			   ;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
					|
					(ActualParam) Expr
					;

Designator ::= (Designator) IDENT:name
;

Addop ::= (Addop) PLUS ;

					
          	          